
name: Build and Deploy Conductor to EC2

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_SERVER: conductor/server
  ECR_REPOSITORY_UI: conductor/ui
  EC2_INSTANCE_ID: i-0f3825346d84a197a 

jobs:
  build-server:
    name: Build Conductor Server Image
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::867344440197:role/GitHubActionsRole 
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push server image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # This command uses the repository root as the build context.
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_SERVER:$IMAGE_TAG -f docker/server/Dockerfile .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_SERVER:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_SERVER:$IMAGE_TAG" >> $GITHUB_OUTPUT

  build-ui:
    name: Build Conductor UI Image
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::867344440197:role/GitHubActionsRole 
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Fix UI Dockerfile command
        run: |
          # This step explicitly adds the monaco-editor package before the build.
          sed -i 's|RUN yarn install && cp -r node_modules/monaco-editor public/ && yarn build|RUN yarn add monaco-editor && cp -r node_modules/monaco-editor public/ && yarn build|' docker/ui/Dockerfile

      - name: Build, tag, and push UI image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG -f docker/ui/Dockerfile .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_UI:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [build-server, build-ui]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::867344440197:role/GitHubActionsRole # <-- IMPORTANT: Replace with your IAM Role ARN
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to EC2 via SSM
        env:
          SERVER_IMAGE_URI: ${{ needs.build-server.outputs.image_uri }}
          UI_IMAGE_URI: ${{ needs.build-ui.outputs.image_uri }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # This heredoc defines the shell script that will be executed on the EC2 instance.
          # It now runs the full 8-container development stack.
          COMMANDS_JSON=$(cat <<EOF
          {
            "commands": [
              "#!/bin/bash",
              "set -e",
              "echo '--- Logging into Amazon ECR ---'",
              "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}",
              
              "echo '--- Stopping and removing old containers ---'",
              "docker stop conductor-server conductor-ui redis elasticsearch mongo schellar nats nats-streaming || true",
              "docker rm conductor-server conductor-ui redis elasticsearch mongo schellar nats nats-streaming || true",

              "echo '--- Cleaning up Docker system to free up space ---'",
              "docker system prune -af",

              "echo '--- Removing old Docker network ---'",
              "docker network rm conductor-dev-net || true",

              "echo '--- Creating Docker network ---'",
              "docker network create conductor-dev-net",

              "echo '--- Pulling new images from ECR ---'",
              "docker pull ${{ env.SERVER_IMAGE_URI }}",
              "docker pull ${{ env.UI_IMAGE_URI }}",

              "echo '--- Starting Redis container ---'",
              "docker run -d --name redis --network conductor-dev-net -p 6379:6379 --restart always redis:6.2-alpine",

              "echo '--- Starting Elasticsearch container ---'",
              "docker run -d --name elasticsearch --network conductor-dev-net -p 9200:9200 -p 9300:9300 -e 'discovery.type=single-node' --restart always docker.elastic.co/elasticsearch/elasticsearch:7.17.11",
              
              "echo '--- Starting MongoDB container ---'",
              "docker run -d --name mongo --network conductor-dev-net -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=root --restart always mongo:4.1.10",

              "echo '--- Starting NATS container ---'",
              "docker run -d --name nats --network conductor-dev-net -p 4222:4222 -p 8222:8222 --restart always nats:latest -js --http_port 8222",

              "echo '--- Starting NATS Streaming container ---'",
              "docker run -d --name nats-streaming --network conductor-dev-net -p 4223:4222 -p 8223:8222 --restart always nats-streaming:latest",

              "echo '--- Starting new Conductor Server container ---'",
              "docker run -d --name conductor-server --network conductor-dev-net -p 8080:8080 -e conductor.db.type=redis_standalone -e conductor.redis.server=redis://redis:6379 -e conductor.elasticsearch.url=http://elasticsearch:9200 --restart always ${{ env.SERVER_IMAGE_URI }}",

              "echo '--- Starting Schellar container ---'",
              "docker run -d --name schellar --network conductor-dev-net -p 3001:3000 -e CONDUCTOR_API_URL=http://conductor-server:8080/api -e MONGO_ADDRESS=mongo -e MONGO_USERNAME=root -e MONGO_PASSWORD=root --restart always flaviostutz/schellar",

              "echo '--- Starting new Conductor UI container ---'",
              "docker run -d --name conductor-ui --network conductor-dev-net -p 5000:5000 -e WF_SERVER=http://conductor-server:8080/api --restart always ${{ env.UI_IMAGE_URI }}",

              "echo '--- Deployment script finished ---'"
            ]
          }
          EOF
          )

          # This command sends the script to the EC2 instance via SSM and polls for its completion status.
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "Deploying Conductor commit: ${{ github.sha }}" \
            --targets "Key=InstanceIds,Values=${{ env.EC2_INSTANCE_ID }}" \
            --parameters "$COMMANDS_JSON" \
            --region ${{ env.AWS_REGION }} \
            --query "Command.CommandId" \
            --output text)

          echo "Waiting for SSM command to complete..."
          while true; do
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.EC2_INSTANCE_ID }}" \
              --region ${{ env.AWS_REGION }} \
              --query 'CommandInvocations[0].Status' \
              --output text)
            echo "Current deployment status: $STATUS"

            if [[ "$STATUS" == "Success" ]]; then
              echo "✅ Deployment completed successfully!"
              break
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "❌ Deployment failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ env.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi
            sleep 10
          done
